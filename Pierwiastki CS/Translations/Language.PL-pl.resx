<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AboutForm" xml:space="preserve">
    <value>O programie</value>
  </data>
  <data name="AboutForm.lblAppTitle" xml:space="preserve">
    <value>Numerical Calculator</value>
  </data>
  <data name="AboutForm.lblVersion" xml:space="preserve">
    <value>Wersja</value>
  </data>
  <data name="AboutForm.txtDescription" xml:space="preserve">
    <value>Program do obliczeń naukowych i inżynierskich. Posiada zaimplementowany kalkulator, metody szukania pierwiastków funkcji, potrafi obliczyć wartość funkcji, pierwszej i drugiej pochodnej w dowolonym punkcie. Dodatkowo możliwe jest zinterpolowanie wzoru funkcji wielomianowej dla dowolnej ilosci punktów i wykreślenie jej wykresu (jak rownież innej dowolonej).
Program jest główną częścią pracy inżynierskiej "Oprogramowanie wspierające obliczenia naukowe i inżynierskie".</value>
  </data>
  <data name="aboutToolStripMenuItem" xml:space="preserve">
    <value>O programie</value>
  </data>
  <data name="applicationToolStripMenuItem" xml:space="preserve">
    <value>Program</value>
  </data>
  <data name="btnCompute" xml:space="preserve">
    <value>Oblicz</value>
  </data>
  <data name="btnDraw" xml:space="preserve">
    <value>Rysuj</value>
  </data>
  <data name="chkDifferential" xml:space="preserve">
    <value>Równanie różniczkowe</value>
  </data>
  <data name="chkDifferentialII" xml:space="preserve">
    <value>R. różniczkowe drugiego rzędu</value>
  </data>
  <data name="chkFirstDerivative" xml:space="preserve">
    <value>Pierwsza pochodna</value>
  </data>
  <data name="chkFunction" xml:space="preserve">
    <value>Funkcja</value>
  </data>
  <data name="chkRescaling" xml:space="preserve">
    <value>Automatyczne skalowanie</value>
  </data>
  <data name="chkSecondDerivative" xml:space="preserve">
    <value>Druga pochodna</value>
  </data>
  <data name="chkSpecialFunction" xml:space="preserve">
    <value>Funkcja specjalna</value>
  </data>
  <data name="closeToolStripMenuItem" xml:space="preserve">
    <value>Zakończ</value>
  </data>
  <data name="extraComputationsToolStripMenuItem" xml:space="preserve">
    <value>Dodatkowe obliczenia</value>
  </data>
  <data name="fileToolStripMenuItem" xml:space="preserve">
    <value>Plik</value>
  </data>
  <data name="FunctionForm" xml:space="preserve">
    <value>Funkcje</value>
  </data>
  <data name="FunctionForm.lblBody" xml:space="preserve">
    <value>Sinus = sin
Sinus hiperboliczny = sinh
Cosinus = cos
Cosinus hiperboliczny = cosh
Tangens = tg, tan
Tangens hiperboliczny = tgh, tanh
Cotangens = ctg, ctn, cot
Cotangens hiperboliczny = ctgh, ctnh, coth
Secans = sec
Cosecans = csc
Arcsin = asin
Arccos = acos
Arctg = atg
Arcctg = actg
Funkcja wykładnicza o podstawie e = exp
Pierwiastek = sqrt
Logarytm o podstawie 2 = lg
Logarytm o podstawie e = ln
Logarytm o podstawie 10 = log

Silnia z liczb naturalnych mniejszych od 20 jest liczona standardowym wzorem np. 5! = 1*2*3*4*5
Natomiast silnia z liczb rzeczywistych i naturalnych większych i równych 20 jest funkcją gamma.

Dozwolone, lecz nie wskazane, jest używanie wyrażeń sinx zamiast sin(x).
Lecz sinx+2 = sin(x)+2

W funkcjach można używać PI oraz E. Za PI zostanie podstawiona wartość 3.14159265358979,
natomiast za E liczba 10 podniesiona do występującej po E potęgi.
Np.: E-05 = 10^(-5)

UWAGA!!
Gdy program w argumentach operacji nie będzie mógł zweryfikować poprawności
wprowadzonego wyrażenia, to za E podstawi liczbę Eulera, informując o tym komunikatem! 
Gdy w granicy całkowania podamy E, to zostanie w to miejsce podstawiona wartość 2.71828183.
Np.: Całka sin(x) w granicach od -E do 2/3*E oznacza całkę w granicach od -2.718 do 2/3*2.718

Program nie zwraca uwagi na spacje.

Program nie potrafi operować na liczbach urojonych. Jeżeli w którymś momencie obliczeń
znajdą się operacje na liczbach urojonych, to program zwróci "nie jest liczbą".

Program POTRAFI liczyć wyrażenia zagnieżdżone typu sin(cos(30)+tg(sqrt(0,4)))</value>
  </data>
  <data name="FunctionForm.lblHeader" xml:space="preserve">
    <value>W programie można używać następujących funkcji:</value>
  </data>
  <data name="FunctionForm.lblOperators" xml:space="preserve">
    <value>Operatory:  +, -, *, /, ^, !</value>
  </data>
  <data name="functionsToolStripMenuItem" xml:space="preserve">
    <value>Funkcje</value>
  </data>
  <data name="gbConditions" xml:space="preserve">
    <value>Warunki</value>
  </data>
  <data name="gbDrawFunction" xml:space="preserve">
    <value>Rysuj</value>
  </data>
  <data name="gbFunction" xml:space="preserve">
    <value>Funkcja</value>
  </data>
  <data name="gbOperation" xml:space="preserve">
    <value>Operacja</value>
  </data>
  <data name="gbPoint" xml:space="preserve">
    <value>Punkt</value>
  </data>
  <data name="gbResult" xml:space="preserve">
    <value>Wynik</value>
  </data>
  <data name="gbScale" xml:space="preserve">
    <value>Skala</value>
  </data>
  <data name="graphPreviewWhileWindowsScalingToolStripMenuItem" xml:space="preserve">
    <value>Podgląd wykresu podczas skalowania okna</value>
  </data>
  <data name="graphToolStripMenuItem" xml:space="preserve">
    <value>Wykres</value>
  </data>
  <data name="interpolationApproximationToolStripMenuItem" xml:space="preserve">
    <value>Interpolacja i aproksymacja</value>
  </data>
  <data name="InterpolationForm" xml:space="preserve">
    <value>Interpolacja</value>
  </data>
  <data name="InterpolationForm.btnApply" xml:space="preserve">
    <value>Zatwierdź</value>
  </data>
  <data name="InterpolationForm.btnCompute" xml:space="preserve">
    <value>Oblicz</value>
  </data>
  <data name="InterpolationForm.gbApproximation" xml:space="preserve">
    <value>Aproksymacja</value>
  </data>
  <data name="InterpolationForm.gbInterpolation" xml:space="preserve">
    <value>Interpolacja</value>
  </data>
  <data name="InterpolationForm.rbApproximation" xml:space="preserve">
    <value>Aproksymacja stopnia</value>
  </data>
  <data name="InterpolationForm.rbInterpolation" xml:space="preserve">
    <value>Interpolacja Lagrange'a</value>
  </data>
  <data name="lblCalculationTime" xml:space="preserve">
    <value>Czas obliczeń</value>
  </data>
  <data name="lblCutoff" xml:space="preserve">
    <value>Próg odcięcia</value>
  </data>
  <data name="lblSampling" xml:space="preserve">
    <value>Próbkowanie</value>
  </data>
  <data name="LinearEquationForm" xml:space="preserve">
    <value>Równania liniowe</value>
  </data>
  <data name="LinearEquationForm.btnCompute" xml:space="preserve">
    <value>Oblicz</value>
  </data>
  <data name="LinearEquationForm.lblNumberOfVariables" xml:space="preserve">
    <value>Ilość zmiennych</value>
  </data>
  <data name="LinearEquationForm.lblResults" xml:space="preserve">
    <value>Wyniki:</value>
  </data>
  <data name="linearEquationToolStripMenuItem" xml:space="preserve">
    <value>Równania liniowe</value>
  </data>
  <data name="multipleIntegralToolStripMenuItem" xml:space="preserve">
    <value>Całka wielokrotna</value>
  </data>
  <data name="optionsToolStripMenuItem" xml:space="preserve">
    <value>Opcje</value>
  </data>
  <data name="rbCalculator" xml:space="preserve">
    <value>Kalkulator</value>
  </data>
  <data name="rbDerivativePoint" xml:space="preserve">
    <value>Pierwsza pochodna</value>
  </data>
  <data name="rbDerivativePointBis" xml:space="preserve">
    <value>Druga pochodna</value>
  </data>
  <data name="rbDifferential" xml:space="preserve">
    <value>Równanie różniczkowe</value>
  </data>
  <data name="rbDifferentialII" xml:space="preserve">
    <value>Równanie różniczkowe II rzędu</value>
  </data>
  <data name="rbHybrid" xml:space="preserve">
    <value>Pierwiastek</value>
  </data>
  <data name="rbIntegral" xml:space="preserve">
    <value>Całka</value>
  </data>
  <data name="rbPoint" xml:space="preserve">
    <value>Wartość funkcji w punkcie</value>
  </data>
  <data name="rbSpecialFunction" xml:space="preserve">
    <value>Funkcje specjalne</value>
  </data>
</root>